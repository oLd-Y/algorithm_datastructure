[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/?envType=daily-question&envId=2023-09-15)
# 思路
1. 不能选相邻的，则要么是`上上个+当前`，要么就是`上一个`
2. 留出第0个位置方便统一
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = nums[0]
        for i in range(2, n + 1):
            dp[i] = max(dp[i-2] + nums[i - 1], dp[i-1])
        return dp[n]
```

## 复杂度
1. 时间复杂度：$O(n)$
2. 空间复杂度：$O(n)$

# 优化
1. 遍历过程中仅需要知道上一个和上上个，所以只需要两个变量即可

